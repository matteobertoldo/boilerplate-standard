// @mixin breakpoint
// @author: foundation.zurb.com
// @component: core
// @note: Licensed under MIT Open Source

@if nth(map-values($breakpoints), 1) != 0 {
    @error 'Your smallest breakpoint (defined in $breakpoints) must be set to "0".';
} @else {
    $-zf-zero-breakpoint: nth(map-keys($breakpoints), 1);
}

// Mixin for wraps a media query around the content you put inside the mixin.
// @param: {Keyword|Number} $value - Breakpoint name, or px, rem, or em value to process.
// @output: If the breakpoint is "0px and larger", outputs the content as-is. Otherwise, outputs the content wrapped in a media query.
// @note: If a string is passed, the mixin will look for it in the `$breakpoints` map, and use a media query there.

@mixin breakpoint($value) {
    $str: breakpoint($value);

    @if $str == '' {
        @content;
    } @else {
        @media only screen and #{$str} {
            @content;
        }
    }
}

// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.
// @param: {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.

@mixin -zf-each-breakpoint($small: true) {
    $map: $breakpoint-classes;

    @if not $small {
        $map: map-remove($map, $-zf-zero-breakpoint);
    }

    @each $size in $map {
        $-zf-size: $size !global;

        @include breakpoint($size) {
            @content;
        }
    }
}
