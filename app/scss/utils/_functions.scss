// @global functions
// @author: mbertoldo@alpenite.com
// @include: style.scss
// @component: core

// Function for string replace.
// @param: {String}
// @returns: str-replace($mystring, $string-to-replace, $replacer);
// @note: https://css-tricks.com/snippets/sass/str-replace-function/
// ----------------------------------------------------------------------

@function str-replace($string, $search, $replace: "") {
	$index: str-index($string, $search);

	@if $index {
		@return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
	}

	@return $string;
}

// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
// @param: {Number} $num - Number to strip unit from.
// @returns: {Number} The same number, sans unit.

@function strip-unit($num) {
	@return $num / ($num * 0 + 1);
}

// Function for transform "px" value to "em".
// @note: use -> font-size: em(16px) == font-size: 1em;
// ----------------------------------------------------------------------

@function em($size) {
	$em: $size / 16px;

	@return $em * 1em;
}

// Function for transform "px" value to "rem".
// @note: use -> font-size: rem(16px) == font-size: 1rem;
// ----------------------------------------------------------------------

@function rem($size) {
	$rem: $size / 16px;

	@return $rem * 1rem;
}

// Function for loop heading tags.
// @note: set start and end value to loop headings (comma separated);
// ----------------------------------------------------------------------

@function headings($from: 1, $to: 6) {
    @if $from == $to {
        @return 'h#{$from}';
    } @else {
        @return 'h#{$from},' + headings($from + 1, $to);
    }
}

// Function for find the next key in a map.
// @access: private
// @param: {Map} $map - Map to traverse.
// @param: {Mixed} $key - Key to use as a starting point.
// @returns: {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.
// @author: foundation.zurb.com
// @note: Licensed under MIT Open Source
// ----------------------------------------------------------------------

@function -zf-map-next($map, $key) {
    $values: map-keys($map);
    $i: 0;

    @if (map-has-key($map, $key)) {
        $i: index($values, $key) + 1;
    }

    @if ($i > length($map) or $i == 0) {
        @return null;
    } @else {
        @return map-get($map, nth($values, $i));
    }
}

// Generates a media query string matching the input value.
// @param: {Keyword|Number} $val [small] - Breakpoint name, or px, rem, or em value to process.
// @param: `retina` set a "non vendor" prefix for autoprefixer: (less -webkit-) edited.
// @require: {Function} -zf-map-next
// @note: Refer to the documentation for the `breakpoint()` mixin to see what the possible inputs are.
// @note: edited `em` breakpoint parse value.
// ----------------------------------------------------------------------

@function breakpoint($val: $-zf-zero-breakpoint) {
    $bp: nth($val, 1);
    $bp-max: 0;
    $dir: if(length($val) > 1, nth($val, 2), up);
    $str: '';
    $named: false;

	@if $bp == 'landscape' or $bp == 'portrait' {
		@return '(orientation: #{$bp})';
	} @else if $bp == 'retina' {
		@return '(min-device-pixel-ratio: 2), (min-resolution: 192dpi)';
    }

    @if type-of($bp) == 'string' {
        @if map-has-key($breakpoints, $bp) {
            @if $dir == 'only' or $dir == 'down' {
                $bp-max: -zf-map-next($breakpoints, $bp);
            }

            $bp: map-get($breakpoints, $bp);
            $named: true;
        } @else {
            $bp: 0;

            @warn 'breakpoint(): "#{$val}" is not defined in your $breakpoints setting.';
        }
    }

	@if $bp > 0 or $dir == 'only' or $dir == 'down' {
		@if $dir == 'only' {
			@if $named == true {
		        @if $bp > 0 {
					$str: $str + '(min-width: #{$bp})';

					@if $bp-max != null {
						$str: $str + ' and ';
					}
			  	}

				@if $bp-max != null {
					$str: $str + '(max-width: #{$bp-max})';
			    }
			} @else {
				@warn 'breakpoint(): Only named media queries can have an `only` range.';
			}
	   	} @else if $dir == 'down' {
			$max: if($named, $bp-max, $bp);

			@if $named or $bp > 0 {
				@if $max != null {
					$str: $str + '(max-width: #{$max})';
				}
			}
		} @else if $bp > 0 {
			$str: $str + '(min-width: #{$bp})';
	    }
	}

	@return $str;
}

// Get a value for a breakpoint from a responsive config map. If the config map has the key `$value`, the exact breakpoint value is returned. If the config map does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.
// @access private
// @param: {Map} $map - Input config map.
// @param: {Keyword} $value - Breakpoint name to use.
// @return: {Mixed} The corresponding breakpoint value.
// ----------------------------------------------------------------------

@function -zf-get-bp-val($map, $value) {
	@if not map-has-key($breakpoints, $value) {
		@return null;
	} @else if map-has-key($map, $value) {
		@return map-get($map, $value);
	} @else {
		$anchor: null;
		$found: false;

		@each $key, $val in $breakpoints {
			@if not $found {
				@if map-has-key($map, $key) {
					$anchor: $key;
				}

				@if $key == $value {
					$found: true;
				}
			}
		}

		@return map-get($map, $anchor);
	}
}

// Calculates the width of a column based on a number of factors.
// @param: {Number|List} $columns
// @returns: {Number} A calculated percentage value.
// @author: foundation.zurb.com
// @note: Licensed under MIT Open Source
// ----------------------------------------------------------------------

@function grid-column($columns) {
	$width: 0%;

	@if type-of($columns) == 'number' {
		@if unit($columns) == '%' {
			$width: $columns;
		} @else if $columns < 1 {
			$width: percentage($columns);
		} @else {
			$width: percentage($columns / $grid-column-count);
		}
	} @else if type-of($columns) == 'list' {
		@if length($columns) != 3 {
			@error 'Wrong syntax for grid-column(). Use the format "n of n".';
		} @else {
			$width: percentage(nth($columns, 1) / nth($columns, 3));
		}
	} @else {
		@error 'Wrong syntax for grid-column(). Use a number, decimal, percentage, or "n of n".';
	}

	@return $width;
}

// Shorthand for `grid-column()`.
// @alias grid-column
// @author: foundation.zurb.com
// @note: Licensed under MIT Open Source
// ----------------------------------------------------------------------

@function grid-col($columns: $grid-column-count) {
	@return grid-column($columns);
}

// Get a gutter size for a given breakpoint
// @param {Keyword} $breakpoint [small] - Breakpoint name.
// @param {Number|Map} $gutters [$grid-column-gutter] - Gutter map or single value to use. Responsive gutter settings by default.
// @returns {Number} Gutter size.
// @author: foundation.zurb.com
// @note: Licensed under MIT Open Source
// ----------------------------------------------------------------------

@function grid-column-gutter($breakpoint: $-zf-zero-breakpoint, $gutters: $grid-column-gutter) {
	@if type-of($gutters) == 'number' {
		@return $gutters;
	}

	@return -zf-get-bp-val($gutters, $breakpoint);
}
